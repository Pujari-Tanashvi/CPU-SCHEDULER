<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
    <link rel="stylesheet" href="stylee.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="docs.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <title>OS Virtual Lab</title>
</head>

<body>
    <section class="sub-header">
        <nav>
            <a href="os.html">OS LAB</a>
            <div class="nav-links" id="navLinks">
                <i class="fas fa-window-close" onclick="hideMenu()"></i>
                <ul>
                    <li><a href="os.html">HOME</a></li>
                    <li><a href="docs.html">DOCS</a></li>
                    <!-- <li><a href="blog.html">BLOG</a></li> -->
                    <li><a href="ganttcharts.html">SIMULATOR</a></li>
                    <li><a href="about.html">ABOUT</a></li>

                </ul>
            </div>
            <i class="fas fa-bars" onclick="showMenu()"></i>
        </nav>

        <h1>Documentation</h1>

    </section>



    <section class="container_docs" >
        <h1>What is CPU Scheduling?</h1>
        <p>CPU Scheduling is a process of determining which process will own CPU for execution while another process is
            on hold. The main task of CPU scheduling is to make sure that whenever the CPU remains idle, the OS at least
            select one of the processes available in the ready queue for execution. The selection process will be
            carried out by the CPU scheduler. It selects one of the processes in memory that are ready for execution.
        </p>
    </section>

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Why CPU Scheduling?</h1>
        <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent
            waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can
            use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br>
            <strong>Objectives of Process Scheduling Algorithm</strong>
            <li>Max CPU utilization [Keep CPU as busy as possible]</li>
            <li>Fair allocation of CPU.</li>
            <li>Max throughput [Number of processes that complete their execution per time unit]</li>
            <li>Min turnaround time [Time taken by a process to finish execution]</li>
            <li>Min waiting time [Time a process waits in ready queue]</li>
            <li>Min response time [Time when a process produces first response]</li>

        </p>
    </section>

    <section class="container_docs special" data-aos="zoom-in-up">
        <h1>Important CPU scheduling Terminologies</h1>
        <!-- <p>A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.<br><br> -->
        <li><strong>Burst Time/Execution Time:</strong> It is a time required by the process to complete execution. It
            is also called running time.</li>
        <li><strong>Arrival Time:</strong> when a process enters in a ready state</li>
        <li><strong>Finish Time:</strong> when process complete and exit from a system</li>
        <li><strong>Multiprogramming:</strong> A number of programs which can be present in memory at the same time.
        </li>
        <li><strong>Jobs:</strong> It is a type of program without any kind of user interaction.</li>
        <li><strong>User:</strong> It is a kind of program having user interaction.</li>
        <li><strong>Process:</strong> It is the reference that is used for both job and user.</li>
        <li><strong>CPU/IO burst cycle:</strong> Characterizes process execution, which alternates between CPU and I/O
            activity. CPU times are shorter than the time of I/O.</li>

        </p>
    </section>











    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU Scheduling</h1>
        <p>There is mainly two major types of CPU Scheduling which is listed below.There is sub-types of this algorithm also. we have discussed all algorithm in details below. </p>
        <li>Preemptive Algorithm</li>
        <li>Non Preemptive Algorithm</li>
        <br>

        <p><strong class="bold">Preemptive Scheduling</strong><br><br>
            In Preemptive Scheduling, the tasks are mostly assigned with their priorities. Sometimes it is important to
            run a task with a higher priority before another lower priority task, even if the lower priority task is
            still running. The lower priority task holds for some time and resumes when the higher priority task
            finishes its execution.<br><br>
            <br>
            <strong class="bold">Non-Preemptive Scheduling</strong><br><br>
            In this type of scheduling method, the CPU has been allocated to a specific process. The process that keeps
            the CPU busy will release the CPU either by switching context or terminating. It is the only method that can
            be used for various hardware platforms. That’s because it doesn’t need special hardware (for example, a
            timer) like preemptive scheduling.
        </p>

        

    </section>


    <section class="container_docs" data-aos="zoom-in-up">
        <h1>Types of CPU scheduling Algorithm</h1>
        <p>There are mainly six types of process scheduling algorithm</p>
        <!-- <lo> -->
        <li>First Come First Serve (FCFS)</li>
        <li>Shortest-Job-First (SJF) Scheduling</li>
        <li>Shortest Remaining Time</li>
        <li>Priority Scheduling</li>
        <li>Round Robin Scheduling</li>
        <li>Multilevel Queue Scheduling</li>
        <br>
    </section>



    <section class="container_docs" data-aos="zoom-in-up">
        <h1>1) First Come First Serve</h1>
        <p>First Come First Serve is the full form of FCFS. It is the easiest and most simple CPU scheduling algorithm.
            In this type of algorithm, the process which requests the CPU gets the CPU allocation first. This scheduling
            method can be managed with a FIFO queue.<br><br>

            As the process enters the ready queue, its PCB (Process Control Block) is linked with the tail of the queue.
            So, when CPU becomes free, it should be assigned to the process at the beginning of the queue.</p>

        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. It is simple and easy to understand.<br></p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. The process with less execution time suffer i.e. waiting time is often quite long.<br><br>
            2. Favors CPU Bound process then I/O bound process.<br><br>
            3. FCFS algorithm is particularly troublesome for time-sharing systems, where it is important that each user
            get a share of the CPU at regular intervals.</p>
            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

   

    <section class="container_docs" data-aos="zoom-in-up">
        <h1>3) Priority Based Scheduling</h1>
        <p>Priority scheduling is a method of scheduling processes based on priority. In this method, the scheduler
            selects the tasks to work as per the priority.<br><br>

            Priority scheduling also helps OS to involve priority assignments. The processes with higher priority should
            be carried out first, whereas jobs with equal priorities are carried out on a round-robin or FCFS basis.
            Priority can be decided based on memory requirements, time requirements, etc.<br><br>

        </p>
        <h4>
            <li>Advantages</li>
        </h4>
        <p>1. This provides a good mechanism where the relative importance of each process maybe precisely defined.<br>
        </p>

        <h4>
            <li>Disadvantages</li>
        </h4>
        <p>1. If high priority processes use up a lot of CPU time, lower priority processes may starve and be postponed
            indefinitely.The situation where a process never gets scheduled to run is called starvation<br><br>
            2. Another problem is deciding which process gets which priority level assigned to it..<br></p>
            <button class="btn_1" onclick="gotoSimulator();">Go to Simulator</button>
        <br>
    </section>

   

   

  

     
    <section class="footer">
        <!-- <h4>About Us</h4>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Soluta pariatur eveniet eaque provident error velit totam quos. Corrupti sunt omnis<br>  eligendi ut enim, sed magnamquo laboriosam, aspernatur nulla ipsum commodi itaque accusantium sapiente!</p> -->

        <div class="icons">
            <a href="https://www.facebook.com"><i  class="fab fa-facebook"></i></a>
            <a href="https://www.instagram.com/invites/contact/?i=17s1o7wfms500&utm_content=i08g8yn"><i class="fab fa-instagram"></i></a>
            <a href="https://twitter.com/Krutarth12345?t=JASTMDZLzUB4VOR-OEd_kg&s=09"><i class="fab fa-twitter"></i></a>
            <a href="https://www.linkedin.com/in/krutarth-patel-653065205 "><i class="fab fa-linkedin"></i></a>
        </div>
            
        <p>Made With <i class="far fa-heart"></i>by Tanashvi pujari</p>
        <p> <i class="fa fa-copyright"></i> copyright 2022 || All rights reserved</p>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"
        integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13"
        crossorigin="anonymous"></script>

    <script>
        var navLinks = document.getElementById("navLinks");
        function showMenu() {
            navLinks.style.right = "0";
        }

        function hideMenu() {
            navLinks.style.right = "-200px";
        }

        function gotoSimulator(){
            location.href = ("ganttcharts.html");
        }
    </script>


    <!-- For the animation -->
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>
      AOS.init({
        offset: 200, // offset (in px) from the original trigger point
        duration: 800
      });
    </script>
</body>

</html>